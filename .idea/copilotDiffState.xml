<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/controller/ClientController.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/controller/ClientController.kt" />
              <option name="originalContent" value="package com.example.demo.controller&#10;&#10;import com.example.demo.service.ClientService&#10;import com.example.demo.model.Client&#10;import com.example.demo.dto.ClientDTO&#10;import com.example.demo.dto.AccountDTO&#10;import com.example.demo.dto.LoginRequest&#10;import org.springframework.http.ResponseEntity&#10;import org.springframework.web.bind.annotation.*&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api&quot;)&#10;class ClientController(private val clientService: ClientService) {&#10;&#10;    @PostMapping(&quot;/clients&quot;)&#10;    fun createClient(@RequestBody client: Client): ResponseEntity&lt;ClientDTO&gt; {&#10;        val savedClient = clientService.createClient(client)&#10;        val account = savedClient.account?.let {&#10;            AccountDTO(it.id, it.accountNumber, it.balance)&#10;        }&#10;        val clientDTO = ClientDTO(&#10;            savedClient.id,&#10;            savedClient.name,&#10;            savedClient.email,&#10;            savedClient.cpf,&#10;            savedClient.birthDate?.toString(),&#10;            savedClient.address,&#10;            savedClient.phone,&#10;            savedClient.isActive,&#10;            account&#10;        )&#10;        return ResponseEntity.ok(clientDTO)&#10;    }&#10;&#10;    @GetMapping(&quot;/clients&quot;)&#10;    fun getAllClients(): ResponseEntity&lt;List&lt;ClientDTO&gt;&gt; {&#10;        val clients = clientService.getAllClients()&#10;        val clientDTOs = clients.map { client -&gt;&#10;            val account = client.account?.let {&#10;                AccountDTO(it.id, it.accountNumber, it.balance)&#10;            }&#10;            ClientDTO(&#10;                client.id,&#10;                client.name,&#10;                client.email,&#10;                client.cpf,&#10;                client.birthDate?.toString(),&#10;                client.address,&#10;                client.phone,&#10;                client.isActive,&#10;                account&#10;            )&#10;        }&#10;        return ResponseEntity.ok(clientDTOs)&#10;    }&#10;&#10;    @GetMapping(&quot;/clients/{id}&quot;)&#10;    fun getClientById(@PathVariable id: Long): ResponseEntity&lt;ClientDTO&gt; {&#10;        val client = clientService.getClientById(id)&#10;        return if (client != null) {&#10;            val account = client.account?.let {&#10;                AccountDTO(it.id, it.accountNumber, it.balance)&#10;            }&#10;            val clientDTO = ClientDTO(&#10;                client.id,&#10;                client.name,&#10;                client.email,&#10;                client.cpf,&#10;                client.birthDate?.toString(),&#10;                client.address,&#10;                client.phone,&#10;                client.isActive,&#10;                account&#10;            )&#10;            ResponseEntity.ok(clientDTO)&#10;        } else {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;&#10;    @PutMapping(&quot;/clients/{id}&quot;)&#10;    fun updateClient(@PathVariable id: Long, @RequestBody client: Client): ResponseEntity&lt;Client&gt; {&#10;        val updatedClient = clientService.updateClient(id, client)&#10;        return if (updatedClient != null) {&#10;            ResponseEntity.ok(updatedClient)&#10;        } else {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/clients/{id}&quot;)&#10;    fun deleteClient(@PathVariable id: Long): ResponseEntity&lt;Void&gt; {&#10;        return try {&#10;            clientService.deleteClient(id)&#10;            ResponseEntity.noContent().build()&#10;        } catch (e: IllegalArgumentException) {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/login&quot;)&#10;    fun login(@RequestBody loginRequest: LoginRequest): ResponseEntity&lt;ClientDTO&gt; {&#10;        val client = clientService.login(loginRequest.email, loginRequest.password)&#10;        val account = client.account?.let {&#10;            AccountDTO(it.id, it.accountNumber, it.balance)&#10;        }&#10;        val clientDTO = ClientDTO(&#10;            client.id,&#10;            client.name,&#10;            client.email,&#10;            client.cpf,&#10;            client.birthDate?.toString(),&#10;            client.address,&#10;            client.phone,&#10;            client.isActive,&#10;            account&#10;        )&#10;        return ResponseEntity.ok(clientDTO)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.demo.controller&#10;&#10;import com.example.demo.service.ClientService&#10;import com.example.demo.model.Client&#10;import com.example.demo.dto.ClientDTO&#10;import com.example.demo.dto.AccountDTO&#10;import com.example.demo.dto.LoginRequest&#10;import org.springframework.http.ResponseEntity&#10;import org.springframework.web.bind.annotation.*&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api&quot;)&#10;class ClientController(private val clientService: ClientService) {&#10;&#10;    @PostMapping(&quot;/clients&quot;)&#10;    fun createClient(@RequestBody client: Client): ResponseEntity&lt;ClientDTO&gt; {&#10;        val savedClient = clientService.createClient(client)&#10;        val account = savedClient.account?.let {&#10;            AccountDTO(it.id, it.accountNumber, it.balance)&#10;        }&#10;        val clientDTO = ClientDTO(&#10;            savedClient.id,&#10;            savedClient.name,&#10;            savedClient.email,&#10;            savedClient.cpf,&#10;            savedClient.birthDate?.toString(),&#10;            savedClient.address,&#10;            savedClient.phone,&#10;            savedClient.isActive,&#10;            account&#10;        )&#10;        return ResponseEntity.ok(clientDTO)&#10;    }&#10;&#10;    @GetMapping(&quot;/clients&quot;)&#10;    fun getAllClients(): ResponseEntity&lt;List&lt;ClientDTO&gt;&gt; {&#10;        val clients = clientService.getAllClients()&#10;        val clientDTOs = clients.map { client -&gt;&#10;            val account = client.account?.let {&#10;                AccountDTO(it.id, it.accountNumber, it.balance)&#10;            }&#10;            ClientDTO(&#10;                client.id,&#10;                client.name,&#10;                client.email,&#10;                client.cpf,&#10;                client.birthDate?.toString(),&#10;                client.address,&#10;                client.phone,&#10;                client.isActive,&#10;                account&#10;            )&#10;        }&#10;        return ResponseEntity.ok(clientDTOs)&#10;    }&#10;&#10;    @GetMapping(&quot;/clients/{id}&quot;)&#10;    fun getClientById(@PathVariable id: Long): ResponseEntity&lt;ClientDTO&gt; {&#10;        val client = clientService.getClientById(id)&#10;        return if (client != null) {&#10;            val account = client.account?.let {&#10;                AccountDTO(it.id, it.accountNumber, it.balance)&#10;            }&#10;            val clientDTO = ClientDTO(&#10;                client.id,&#10;                client.name,&#10;                client.email,&#10;                client.cpf,&#10;                client.birthDate?.toString(),&#10;                client.address,&#10;                client.phone,&#10;                client.isActive,&#10;                account&#10;            )&#10;            ResponseEntity.ok(clientDTO)&#10;        } else {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;&#10;    @PutMapping(&quot;/clients/{id}&quot;)&#10;    fun updateClient(@PathVariable id: Long, @RequestBody client: Client): ResponseEntity&lt;Client&gt; {&#10;        val updatedClient = clientService.updateClient(id, client)&#10;        return if (updatedClient != null) {&#10;            ResponseEntity.ok(updatedClient)&#10;        } else {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/clients/{id}&quot;)&#10;    fun deleteClient(@PathVariable id: Long): ResponseEntity&lt;Void&gt; {&#10;        return try {&#10;            clientService.deleteClient(id)&#10;            ResponseEntity.noContent().build()&#10;        } catch (e: IllegalArgumentException) {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/login&quot;)&#10;    fun login(@RequestBody loginRequest: LoginRequest): ResponseEntity&lt;String&gt; {&#10;        clientService.login(loginRequest.email, loginRequest.password)&#10;        return ResponseEntity.ok(&quot;Login com sucesso&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/dto/ClientDTO.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/dto/ClientDTO.kt" />
              <option name="originalContent" value="package com.example.demo.dto&#10;&#10;import com.example.demo.model.Address&#10;import com.example.demo.model.Phone&#10;&#10;// DTO para Account sem o campo client&#10;data class AccountDTO(&#10;    val id: Long?,&#10;    val accountNumber: String?,&#10;    val balance: Double?&#10;)&#10;&#10;// DTO para Client sem recursividade&#10;data class ClientDTO(&#10;    val id: Long?,&#10;    val name: String?,&#10;    val email: String?,&#10;    val cpf: String?,&#10;    val birthDate: String?,&#10;    val address: Address?,&#10;    val phone: Phone?,&#10;    val isActive: Boolean?,&#10;    val account: AccountDTO?&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.demo.dto&#10;&#10;import com.example.demo.model.Address&#10;import com.example.demo.model.Phone&#10;&#10;// DTO para Account sem o campo client&#10;data class AccountDTO(&#10;    val id: Long?,&#10;    val accountNumber: String?,&#10;    val balance: Double?&#10;)&#10;&#10;// DTO para Client sem recursividade&#10;data class ClientDTO(&#10;    val id: Long?,&#10;    val name: String?,&#10;    val email: String?,&#10;    val cpf: String?,&#10;    val birthDate: String?,&#10;    val address: Address?,&#10;    val phone: Phone?,&#10;    val isActive: Boolean?,&#10;    val account: AccountDTO?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/dto/LoginRequest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/dto/LoginRequest.kt" />
              <option name="updatedContent" value="package com.example.demo.dto&#10;&#10;data class LoginRequest(&#10;    val email: String,&#10;    val password: String&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/endpoint/GetClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/endpoint/GetClient.kt" />
              <option name="originalContent" value="package com.example.demo.endpoint&#10;&#10;import com.example.demo.model.Client&#10;import com.example.demo.model.Account&#10;import com.example.demo.model.Payment&#10;import org.springframework.web.bind.annotation.GetMapping&#10;import org.springframework.web.bind.annotation.PathVariable&#10;import org.springframework.web.bind.annotation.RequestMapping&#10;import org.springframework.web.bind.annotation.RestController&#10;&#10;&#10;@GetMapping(&quot;/clients/{id}&quot;)&#10;@RestController&#10;@RequestMapping(&quot;/api&quot;)&#10;class GetClient {" />
              <option name="updatedContent" value="package com.example.demo.endpoint&#10;&#10;import com.example.demo.model.Client&#10;import com.example.demo.repository.ClientRepository&#10;import org.springframework.http.ResponseEntity&#10;import org.springframework.web.bind.annotation.GetMapping&#10;import org.springframework.web.bind.annotation.PathVariable&#10;import org.springframework.web.bind.annotation.RequestMapping&#10;import org.springframework.web.bind.annotation.RestController&#10;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api&quot;)&#10;class GetClient(private val clientRepository: ClientRepository) {&#10;    @GetMapping(&quot;/clients/{id}&quot;)&#10;    fun getClientById(@PathVariable id: Long): ResponseEntity&lt;Client&gt; {&#10;        val client = clientRepository.findById(id)&#10;        return if (client.isPresent) {&#10;            ResponseEntity.ok(client.get())&#10;        } else {&#10;            ResponseEntity.notFound().build()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/model/Account.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/model/Account.kt" />
              <option name="originalContent" value="package com.example.demo.model&#10;&#10;import jakarta.persistence.*&#10;&#10;@Entity&#10;@Table(name = &quot;accounts&quot;)&#10;data class Account(&#10;    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    val id: Long = 0,&#10;    @Column(unique = true, nullable = false)&#10;    val accountNumber: String = &quot;&quot;,&#10;    val balance: Double = 0.0,&#10;    @OneToOne&#10;    @JoinColumn(name = &quot;client_id&quot;)&#10;    val client: Client? = null&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.demo.model&#13;&#10;&#13;&#10;import com.fasterxml.jackson.annotation.JsonIgnore&#13;&#10;import jakarta.persistence.*&#13;&#10;&#13;&#10;@Entity&#13;&#10;@Table(name = &quot;accounts&quot;)&#13;&#10;data class Account(&#13;&#10;    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)&#13;&#10;    val id: Long = 0,&#13;&#10;    @Column(unique = true, nullable = false)&#13;&#10;    val accountNumber: String = &quot;&quot;,&#13;&#10;    val balance: Double = 0.0,&#13;&#10;    @OneToOne&#13;&#10;    @JoinColumn(name = &quot;client_id&quot;)&#13;&#10;    @JsonIgnore&#13;&#10;    val client: Client? = null&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/repository/ClientRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/repository/ClientRepository.kt" />
              <option name="originalContent" value="package com.example.demo.repository&#10;&#10;import com.example.demo.model.Client&#10;import org.springframework.data.jpa.repository.JpaRepository&#10;&#10;interface ClientRepository : JpaRepository&lt;Client, Long&gt;" />
              <option name="updatedContent" value="package com.example.demo.repository&#13;&#10;&#13;&#10;import com.example.demo.model.Client&#13;&#10;import org.springframework.data.jpa.repository.JpaRepository&#13;&#10;&#13;&#10;interface ClientRepository : JpaRepository&lt;Client, Long&gt; {&#13;&#10;    fun existsByCpf(cpf: String): Boolean&#13;&#10;    fun existsByEmail(email: String): Boolean&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/service/ClientService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/service/ClientService.kt" />
              <option name="originalContent" value="package com.example.demo.service&#10;&#10;import org.springframework.stereotype.Service&#10;import com.example.demo.model.Client&#10;import com.example.demo.repository.ClientRepository&#10;import com.example.demo.model.Account&#10;import com.example.demo.repository.AccountRepository&#10;import java.util.UUID&#10;&#10;@Service&#10;class ClientService(&#10;    private val clientRepository: ClientRepository,&#10;    private val accountRepository: AccountRepository&#10;) {&#10;    fun createClient(client: Client): Client {&#10;        if (clientRepository.existsByCpf(client.cpf)) {&#10;            throw IllegalArgumentException(&quot;Já existe um cliente com este CPF.&quot;)&#10;        }&#10;        if (clientRepository.existsByEmail(client.email)) {&#10;            throw IllegalArgumentException(&quot;Já existe um cliente com este email.&quot;)&#10;        }&#10;        if (client.password.length &lt; 6) {&#10;            throw IllegalArgumentException(&quot;A senha deve ter pelo menos 6 dígitos.&quot;)&#10;        }&#10;        val accountNumber = UUID.randomUUID().toString().substring(0, 10)&#10;        val account = Account(accountNumber = accountNumber, balance = 0.0)&#10;        val clientWithAccount = client.copy(account = account)&#10;        val savedClient = clientRepository.save(clientWithAccount)&#10;        val savedAccount = account.copy(client = savedClient)&#10;        accountRepository.save(savedAccount)&#10;        return savedClient&#10;    }&#10;    fun getAllClients(): List&lt;Client&gt; {&#10;        return clientRepository.findAll()&#10;    }&#10;    fun getClientById(id: Long): Client? {&#10;        return clientRepository.findById(id).orElse(null)&#10;    }&#10;    fun updateClient(id: Long, client: Client): Client? {&#10;        return if (clientRepository.existsById(id)) {&#10;            clientRepository.save(client.copy(id = id))&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;    fun deleteClient(id: Long) {&#10;        if (clientRepository.existsById(id)) {&#10;            clientRepository.deleteById(id)&#10;        } else {&#10;            throw IllegalArgumentException(&quot;Client with id $id does not exist&quot;)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.demo.service&#10;&#10;import org.springframework.stereotype.Service&#10;import com.example.demo.model.Client&#10;import com.example.demo.repository.ClientRepository&#10;import com.example.demo.model.Account&#10;import com.example.demo.repository.AccountRepository&#10;import java.util.UUID&#10;&#10;@Service&#10;class ClientService(&#10;    private val clientRepository: ClientRepository,&#10;    private val accountRepository: AccountRepository&#10;) {&#10;    fun createClient(client: Client): Client {&#10;        if (clientRepository.existsByCpf(client.cpf)) {&#10;            throw IllegalArgumentException(&quot;Já existe um cliente com este CPF.&quot;)&#10;        }&#10;        if (clientRepository.existsByEmail(client.email)) {&#10;            throw IllegalArgumentException(&quot;Já existe um cliente com este email.&quot;)&#10;        }&#10;        if (client.password.length &lt; 6) {&#10;            throw IllegalArgumentException(&quot;A senha deve ter pelo menos 6 dígitos.&quot;)&#10;        }&#10;        val accountNumber = UUID.randomUUID().toString().substring(0, 10)&#10;        val account = Account(accountNumber = accountNumber, balance = 0.0)&#10;        val clientWithAccount = client.copy(account = account)&#10;        val savedClient = clientRepository.save(clientWithAccount)&#10;        val savedAccount = account.copy(client = savedClient)&#10;        accountRepository.save(savedAccount)&#10;        return savedClient&#10;    }&#10;    fun getAllClients(): List&lt;Client&gt; {&#10;        return clientRepository.findAll()&#10;    }&#10;    fun getClientById(id: Long): Client? {&#10;        return clientRepository.findById(id).orElse(null)&#10;    }&#10;    fun updateClient(id: Long, client: Client): Client? {&#10;        return if (clientRepository.existsById(id)) {&#10;            clientRepository.save(client.copy(id = id))&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;    fun deleteClient(id: Long) {&#10;        if (clientRepository.existsById(id)) {&#10;            clientRepository.deleteById(id)&#10;        } else {&#10;            throw IllegalArgumentException(&quot;Client with id $id does not exist&quot;)&#10;        }&#10;    }&#10;    fun login(email: String, password: String): Client {&#10;        val client = clientRepository.findAll().find { it.email == email }&#10;            ?: throw IllegalArgumentException(&quot;Email ou senha inválidos.&quot;)&#10;        if (client.password != password) {&#10;            throw IllegalArgumentException(&quot;Email ou senha inválidos.&quot;)&#10;        }&#10;        return client&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>